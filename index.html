<html>
    <head>
        <style>
            html, body { margin: 0; overflow: hidden; }
            #cords { position: absolute; margin: 0px; top: 0px; color: white; background-color: black; }
            #objectCount { position: absolute; top: 5px; color: white; background-color: black; }
            #playerCount { position: absolute; top: 26px; color: white; background-color: black; }
            #chatArea { color: white; bottom: 25px; left: 0px; height: 400px; width: 400px; overflow-y: hidden; position: absolute; }
            #chatInput { position: absolute; left: 0px; bottom: 0px; width: 400px; }
            #leaderboardSlot { z-index: 10; background-color: gray; display: inline-block; padding: 5px; width: 150px; text-align: center; margin: 5px; }
            #leaderboard { transition: 0.5s ease; background-color: #808080e3; margin: 5px; }
        </style>
    </head>
    <body>
        <div id="game" style="display: none;">
            <p id="cords">cords: 0, 0, 0</p>
            <p id="objectCount">objects: 0</p>
            <p id="playerCount">players: 0</p>
            <div id="chatArea"></div>
            <input type="text" id="chatInput" placeholder="press enter to message">
            <div id="leaderboard" style="position: absolute; right: 0px;"></div>
        </div>
        <div id="usernameInput">
            <input onkeydown="return /[a-z0-9!@#$%^&*(){}:;<,>.?/|]/i.test(event.key)" maxlength="50" type="text" id="username" placeholder="enter username">
            <button id="startButton">start</button>
        </div>
        <script type="module">
            import * as THREE from './three.module.js';
            import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
            import { getDatabase, ref, push, onDisconnect, get, child, onValue, set, onChildAdded, onChildRemoved } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js';
            const firebaseConfig = {
                apiKey: "AIzaSyBPC7yG2bP6ninmcuUOoZRyilVx79MfqX4",
                authDomain: "d-game-42445.firebaseapp.com",
                databaseURL: "https://d-game-42445-default-rtdb.firebaseio.com",
                projectId: "d-game-42445",
                storageBucket: "d-game-42445.firebasestorage.app",
                messagingSenderId: "1006407308292",
                appId: "1:1006407308292:web:2e79223d6114af77bc5151",
                measurementId: "G-XFL3RPYLNZ"
            };
            const app = initializeApp(firebaseConfig);
            const database = getDatabase(app);
            const dbRef = ref(database);
            let playerRef = ref(database, "players/");
            set(playerRef, null);
            let objectRef = ref(database, "objects/");
            let messageRef = ref(database, "messages/");
            let playerID = Math.floor(Math.random() * (10000000000 - 1 + 1)) + 1;
            let currentPlayerRef = ref(database, "players/" + playerID);
            let objects = [];
            const scene = new THREE.Scene();
            let FOV = 75;
            let camera = new THREE.PerspectiveCamera(FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("game").appendChild(renderer.domElement);
            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const otherPlayerMaterial = new THREE.MeshBasicMaterial({ color: "red" });
            const player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 5, 0);
            scene.add(player);
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            objects.push(ground);
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            let cubeMaterial = new THREE.MeshBasicMaterial({ color: "rgb(255, 255, 255)" });
            let cooldown = 500;
            document.addEventListener('keydown', (event) => {
                keys[event.key] = true;
                const chatInput = document.getElementById("chatInput");
                if (event.key == "Enter") {
                    if (chatInput.value == "") {
                        chatInput.focus();
                        return;
                    }
                    const chatArea = document.getElementById("chatArea");
                    if (!chatInput.lastMessageTime || Date.now() - chatInput.lastMessageTime > cooldown) {
                        push(messageRef, { username: document.getElementById("username").value, message: chatInput.value });
                        chatInput.value = "";
                        chatInput.lastMessageTime = Date.now();
                        set(messageRef, null);
                        chatInput.blur()
                        chatArea.scrollTop = chatArea.scrollHeight;
                        document.body.requestPointerLock();
                    }
                }
                if (event.key == "Tab") {
                    event.preventDefault();
                    let leaderboard = document.getElementById("leaderboard");
                    if (leaderboard.style.transform == "translateX(175px)") {
                        leaderboard.style.transform = "translateX(0px)";
                    } else {
                        leaderboard.style.transform = "translateX(175px)";
                    }
                }
            });
            document.addEventListener('keyup', (event) => { delete keys[event.key]; });
            let cameraAngleX = 0;
            let cameraAngleY = 0;
            let isMouseDown = true;
            const moveSpeed = 0.1;
            const keys = {};
            const jumpStrength = 0.3;
            const gravity = 0.01;
            let velocityY = 0;
            let isJumping = false;
            let pos = { x: player.position.x, y: player.position.y, z: player.position.z };
            document.addEventListener('mousemove', (event) => {
                cameraAngleX -= event.movementX * 0.0025;
                cameraAngleY -= event.movementY * 0.0025;
            });
            document.body.addEventListener('click', () => {
                if (document.getElementById("usernameInput").style.display == "none") {
                    document.body.requestPointerLock();
                }
            });
            document.getElementById("startButton").addEventListener('click', () => {
                if (document.getElementById("username").value == "") return;
                playerRef = ref(database, "players/");
                pos = { x: player.position.x, y: player.position.y, z: player.position.z, username: document.getElementById("username").value };
                set(currentPlayerRef, pos);
                gameLoop();
                push(messageRef, { username: "System", message: document.getElementById("username").value + " has joined the game" });
                set(messageRef, null);
            });
            function checkCollision(object1, object2) {
                const object1Box = new THREE.Box3().setFromObject(object1);
                const object2Box = new THREE.Box3().setFromObject(object2);
                return object1Box.intersectsBox(object2Box);
            }
            function handleCollisions(otherObject) {
                if (checkCollision(player, otherObject)) {
                    const objectBox = new THREE.Box3().setFromObject(otherObject);
                    const playerBox = new THREE.Box3().setFromObject(player);
                    const intersection = playerBox.intersect(objectBox);
                    if (velocityY < 0 && intersection && intersection.max.y === objectBox.max.y) {
                        player.position.y = objectBox.max.y + playerBox.getSize(new THREE.Vector3()).y / 2 + 0.5;
                        velocityY = 0;
                        isJumping = false;
                    } else {
                        const direction = new THREE.Vector3(Math.sin(cameraAngleX), 0, Math.cos(cameraAngleX));
                        const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                        if (keys['w']) player.position.add(direction.clone().multiplyScalar(moveSpeed));
                        if (keys['s']) player.position.add(direction.clone().multiplyScalar(-moveSpeed));
                        if (keys['d']) player.position.add(right.clone().multiplyScalar(moveSpeed));
                        if (keys['a']) player.position.add(right.clone().multiplyScalar(-moveSpeed));
                    }
                }
            }
            let playerCount = 0;
            let playerString = "";
            function getPlayers() {
                playerCount = 0;
                document.getElementById("leaderboard").innerHTML = "";
                playerString = "";
                get(playerRef).then((snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        for (let key in data) {
                            playerCount++;
                            if (key != playerID) {
                                let existingPlayer = objects.find(obj => obj.userData.id === key);
                                if (existingPlayer) {
                                    existingPlayer.position.lerp(new THREE.Vector3(data[key].x, data[key].y, data[key].z), 0.1);
                                } else {
                                    const newPlayer = new THREE.Mesh(playerGeometry, otherPlayerMaterial);
                                    newPlayer.position.set(data[key].x, data[key].y, data[key].z);
                                    newPlayer.userData.id = key;
                                    const spriteMaterial = new THREE.SpriteMaterial({
                                        map: new THREE.CanvasTexture(makeText(data[key].username)),
                                        transparent: true
                                    });
                                    const sprite = new THREE.Sprite(spriteMaterial);
                                    sprite.scale.set(2, 1, 1);
                                    sprite.position.set(0, 1, 0);
                                    newPlayer.add(sprite);
                                    scene.add(newPlayer);
                                    objects.push(newPlayer);
                                }
                            }
                            playerString = playerString + "<div id='leaderboardSlot'>" + data[key].username + "</div><br>";
                        }
                        document.getElementById("playerCount").textContent = "players: " + playerCount;
                        document.getElementById("leaderboard").innerHTML = "<div id='leaderboardSlot' style='background-color: #696969'><b>players</b></div><br>" + playerString;
                    }
                });
                onChildRemoved(playerRef, (snapshot) => {
                    const data = snapshot.val();
                    let existingPlayer = objects.find(obj => obj.userData.id === snapshot.key);
                    if (existingPlayer) {
                        scene.remove(existingPlayer);
                        objects = objects.filter(obj => obj.userData.id !== snapshot.key);
                    }
                });
            }
            function makeText(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                context.font = 'Bold 60px Arial';
                context.fillStyle = 'white';
                const textWidth = context.measureText(text).width;
                canvas.width = textWidth + 100;
                canvas.height = 100;
                context.font = 'Bold 60px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                return canvas;
            }
            let objectCount = 0;
            const spriteMaterial = new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(makeText(document.getElementById("username").value)),
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 1, 1);
            sprite.position.set(0, 1, 0);
            function getObjects() {
                objectCount = 0;
                get(objectRef).then((snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        for (let key in data) {
                            objectCount++;
                            let existingObject = objects.find(obj => obj.userData.id === key);
                            if (existingObject) {
                                existingObject.position.set(data[key].x, data[key].y, data[key].z);
                            } else {
                                cubeMaterial = new THREE.MeshBasicMaterial({ color: data[key].color });
                                const newObject = new THREE.Mesh(cubeGeometry, cubeMaterial);
                                newObject.position.set(data[key].x, data[key].y, data[key].z);
                                newObject.userData.id = key;
                                scene.add(newObject);
                                objects.push(newObject);
                            }
                        }
                        document.getElementById("objectCount").textContent = "objects: " + objectCount;
                    }
                });
                onChildRemoved(objectRef, (snapshot) => {
                    const data = snapshot.val();
                    let existingObject = objects.find(obj => obj.userData.id === snapshot.key);
                    if (existingObject) {
                        scene.remove(existingObject);
                        objects = objects.filter(obj => obj.userData.id !== snapshot.key);
                    }
                });
            }
            let counter = 0;
            let objectCooldown = 500;
            onDisconnect(currentPlayerRef).remove();
            onChildAdded(messageRef, (snapshot) => {
                const data = snapshot.val();
                const chatArea = document.getElementById("chatArea");
                const message = document.createElement("p");
                message.textContent = data.username + ": " + data.message;
                message.style.margin = "5px";
                message.style.color = "white";
                message.id = "messageP";
                if (data.username == "System") {
                    message.style.fontStyle = "italic";
                }
                if (data.message.includes("/playsound ")) {
                    let command = data.message.split(' ');
                    let sound = command[1];
                    let audioElement = document.createElement("audio");
                    audioElement.src = "https://raw.githubusercontent.com/seaotter6382/seaotter6382.github.io/refs/heads/main/sounds/" + sound + ".mp3";
                    audioElement.autoplay = true;
                    document.body.appendChild(audioElement);
                }
                chatArea.scrollTop = chatArea.scrollHeight;
                chatArea.appendChild(message);
            });
            let radius = 5;
            let objectsClose = 0;
            function gameLoop() {
                objectsClose = 0;
                document.getElementById("game").style.display = "block";
                document.getElementById("usernameInput").style.display = "none";
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const direction = new THREE.Vector3(Math.sin(cameraAngleX), 0, Math.cos(cameraAngleX));
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                let movement = new THREE.Vector3(0, 0, 0);
                if (document.getElementById("chatInput").value == "") {
                    if (keys['s']) player.position.add(direction.clone().multiplyScalar(moveSpeed));
                    if (keys['w']) player.position.add(direction.clone().multiplyScalar(-moveSpeed));
                    if (keys['d']) player.position.add(right.clone().multiplyScalar(-moveSpeed));
                    if (keys['a']) player.position.add(right.clone().multiplyScalar(moveSpeed));
                    if (keys[' '] && !isJumping) { velocityY = jumpStrength; isJumping = true; }
                    if (keys['r']) { player.position.x = 0; player.position.y = 5; player.position.z = 0; }
                    if (keys['c'] && (!player.userData.lastObjectTime || Date.now() - player.userData.lastObjectTime > objectCooldown)) {
                        let color = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                        push(objectRef, { x: player.position.x, y: player.position.y - 1.51, z: player.position.z, color: color });
                        player.userData.lastObjectTime = Date.now();
                    }
                    if (keys['z'] && (!player.userData.lastObjectTime || Date.now() - player.userData.lastObjectTime > objectCooldown)) {
                        push(objectRef, { x: player.position.x, y: player.position.y - 1.51, z: player.position.z, color: "white" });
                        player.userData.lastObjectTime = Date.now();
                    }
                    if (keys['m']) { set(objectRef, null); }
                    if (keys['-']) { FOV += 0.5; }
                    if (keys['=']) { FOV -= 0.5; }
                    if (keys['k']) {
                        renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
                    }
                }
                player.position.add(movement);
                velocityY -= gravity;
                player.position.y += velocityY;
                if (player.position.y < -25) {
                    player.position.x = 0;
                    player.position.y = 5;
                    player.position.z = 0;
                }
                document.getElementById("cords").textContent = "cords: " + Math.round(player.position.x) + ", " + Math.round(player.position.y) + ", " + Math.round(player.position.z);
                let cameraOffset = new THREE.Vector3(Math.sin(cameraAngleX) * radius, 3 + Math.sin(cameraAngleY) * 4, Math.cos(cameraAngleX) * radius);
                camera.position.copy(player.position).add(cameraOffset);
                camera.lookAt(player.position);
                renderer.render(scene, camera);
                camera = new THREE.PerspectiveCamera(FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
                requestAnimationFrame(gameLoop);
                getPlayers();
                getObjects();
                for (let object of objects) {
                    if (player.position.distanceTo(object.position) < 30) {
                        handleCollisions(object);
                        objectsClose++;
                    }
                }
                if (counter > 5) {
                    counter = 0;
                    pos = { x: player.position.x, y: player.position.y, z: player.position.z, username: document.getElementById("username").value };
                    set(currentPlayerRef, pos);
                }
                counter++;
            }
        </script>
    </body>
</html>